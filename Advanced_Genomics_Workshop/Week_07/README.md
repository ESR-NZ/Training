#### Author: Rhys White ([@RhysTWhite](https://twitter.com/RhysTWhite))
#### Affiliations: Institute of Environmental Science and Research - ESR

# Advanced Genomic Insights Workshop Week 07:<br> A tutorial on assembling a genome using long-read sequence data

Table of contents
=================

<!--ts-->
   * [Prerequisites](#prerequisites)
   * [Introduction](#introduction)
   * [Let's get started...](#lets-get-started)
      * [Read _de novo_ assembly](#read-de-novo-assembly)
      * [_De novo_ assembly of nanopore sequence reads with Flye](#de-novo-assembly-of-nanopore-sequence-reads-with-flye)
      * [Polishing an assembly generated from nanopore reads using racon](#polishing-an-assembly-generated-from-nanopore-reads-using-racon)
      * [Polishing an assembly generated from nanopore reads using medaka](#polishing-an-assembly-generated-from-nanopore-reads-using-medaka)
   * [Why have I learnt this?](#why-have-i-learnt-this)
   * [Final notes](#final-notes)
   * [Data availability](#data-availability)
<!--te-->

## Prerequisites
To fully benefit from these exercises, it is essential that you manually _type_ each exercise. Please avoid the temptation to copy and paste, as these exercises aim to train your hands, brain, and mind in the fundamental skills of reading, writing, and comprehending code. By copying and pasting, you would be depriving yourself of the valuable learning experience these lessons provide.

Before we begin, you should have a basic understanding of genomics and the concept of DNA sequencing. You should also be familiar with the command line and have access to a Unix-based operating system (such as Linux or macOS).

Prior completion of the week 05 sequence data [quality control tutorial](https://github.com/ESR-NZ/Training/tree/main/Advanced_Genomics_Workshop/Week_05) is needed. We will analyse the same sequence data in that tutorial for time efficiency.

## Introduction

_De novo_ assembly of nanopore sequence read data involves piecing long DNA sequences (reads) into longer contiguous sequences (contigs) without a reference genome (i.e., without any prior knowledge of their correct sequence or order). Nanopore sequencing offers several advantages, such as long read lengths and real-time sequencing. Still, it also has limitations and specific issues that must be addressed during the assembly process. This tutorial will review the basic _de novo_ assembly of nanopore sequence read data.

## Let's get started...

##### Getting the data

Note: For the [quality control tutorial](https://github.com/ESR-NZ/Training/tree/main/Advanced_Genomics_Workshop/Week_05), you would have downloaded 10 `fastq.gz` files, and then concatenate them into a single `.fastq.gz` file (the suggested name for this concatenated file was `22AR0430_raw_ONT.fastq.gz`. To recap, this `22AR0430_raw_ONT.fastq.gz` file is a compressed text file containing DNA sequence data and corresponding quality scores generated by Nanopore sequencing machines.

You would have investigated the quality of your sequence read data using `nanoQC` and successfully used `NanoFilt` to remove low-quality bases and Illumina adaptor sequences from your reads. 

**The trimmed/filtered reads are what we will be using today.**

##### Creating symbolic links: A step-by-step guide on the command line

Creating soft links, or symbolic links, is a way to reference a file or directory in another location on a Linux or Unix system. Soft links are helpful when creating a shortcut to access a file or directory without making a duplicate copy. This saves space on our system and provides a more efficient method of managing files and directories.

To begin, create a directory called `assembly`. Afterwards, navigate to the `assembly` folder:

```bash
# Make a directory called assembly:
mkdir ONT_assembly
```

```bash
# Change directory to your assembly directory
cd ONT_assembly
```

###### Create the soft link

To create a soft link, use the `ln` command with the `-s` option, followed by the path to the file or directory you want to link, and the name of the soft link you wish to create. Edit this command to create a soft link to the trimmed reads from the [quality control tutorial](https://github.com/ESR-NZ/Training/tree/main/Advanced_Genomics_Workshop/Week_05):

```bash
# Create a soft link to the file with nanopore single-ended reads:
ln -s /path/to/filtered_reads/${SAMPLE}_filtered_ONT.fastq.gz .
```

Replace `${SAMPLE}_filtered_ONT.fastq.gz` with the name of your input file.

To confirm that the file is present in your current working directory, check for their existence using the following command:

```bash
# Directory listing
ls
```

To obtain more information about the `ln` command and its available options, you can execute the command `ln --help`.

### Read _de novo_ assembly

The next step is assembling the nanopore reads into contigs using a _de novo_ assembler. Many _de novo_ assemblers are available, but today we will focus on Flye ([Lin et al. 2016](
https://doi.org/10.1073/pnas.1604560113); [Kolmogorov et al. 2020](https://doi.org/10.1038/s41587-019-0072-8)). Please note that you should have Flye and its dependencies installed on your system before proceeding. You can find more information about the Flye genome assembler from its GitHub repository [https://github.com/fenderglass/Flye](https://github.com/fenderglass/Flye).

Remember to cite the paper:

&emsp; Kolmogorov M, Yuan J, Lin Y, Pevzner PA. Assembly of long, error-prone reads using repeat graphs. _Nature Biotechnology_ 2019;37:540-546 doi [10.1038/s41587-019-0072-8](https://doi.org/10.1038/s41587-019-0072-8)

### _De novo_ assembly of nanopore sequence reads with Flye

Now that you have your sequence data organised, it's time to generate an assembly. You can use the following command as a starting point:

```bash
flye --nano-hq <nanopore_reads>.fastq.gz --genome-size 4.1m --threads 2 --iterations 3 --out-dir <output_directory>
```

- `--nano-hq`: This flag indicates that you are using nanopore reads for assembly (New `--nano-hq` mode for ONT Guppy5+ (SUP mode) and Q20 reads (3-5% error rate))
- `nanopore_reads.fastq.gz`: Replace this with the actual name of your nanopore read file.
- `--genome-size size`: Estimated genome size (for example, 5m or 2.6g)
- `--threads`: Number of parallel threads (CPUs)
- `--iterations`: Number of polishing iterations
- `--out-dir`: Specify the output folder where `Flye` will store the assembly results. Please replace `<output_directory>` with the name of the directory where you want to save the output files.

Keep in mind that if you encounter difficulties or can't recall certain details, you can use `flye --help` which will display helpful documentation.

Once `Flye` completes the assembly, you will find several output files in the specified `<output_directory>`. The primary assembly output will be in the `assembly.fasta` file, which contains the assembled genome. You can use tools like `QUAST` to assess the quality and completeness of your assembly. Remember, we used `QUAST` in [week 06](https://github.com/ESR-NZ/Training/tree/main/Advanced_Genomics_Workshop/Week_06) 

#### Questions

**After generating the `assembly.fasta`, and Log files, and assebly quality metrics (`QUAST`) extract the following information about the assembly:**<br>
**(a) Estimated genome coverage**<br>
**(b) Number of contigs**<br>
**(c) Total genome length**<br>

### Polishing an assembly generated from nanopore reads using racon

We can improve the quality of an assembly using `racon`, a tool specifically designed for polishing long-read genome assemblies. Polishing is a critical step in the genome assembly process, as it helps correct errors and improve the accuracy of the final assembly.

#### Data preparation

Ensure you have the following files ready:

- Nanopore sequencing data in `FASTQ` format (i.e., 22AR0430_filtered_ONT.fastq.gz)
- An initial assembly of the genome in `FASTA` format (i.e., 22AR0430.fasta)

Please make sure these files are located in the same directory where you plan to run `racon`.

#### Polishing with racon

Now, let's proceed with polishing your initial assembly using `racon`. But, before we run `racon`, we will need to map our long reads to our assembly.
To do this, we will use `minimap2`. The basic workflow is as follows:

##### 1) Index the assembly
Before mapping the nanopore reads, you need to index the assembled genome using `minimap2`. 
This will generate a transformed version of the assembly that allows `minimap2` to efficiently map sequences to it. 
You can use the following command as a starting point/guide:

```bash
minimap2 -d <assembly>.mmi <assembly>.fasta
```

The above command creates an index file called `assembly.mmi` from your assembled genome (`assembly`.fasta).
Please replace `<assembly>` with the name of your genome.

##### 2) Map nanopore reads to the assembly

Now, you can map your nanopore reads to the indexed assembled genome using `minimap2`. 
You can use the following command as a starting point/guide:

```bash
minimap2 -x map-ont -t 2 ${SAMPLE}.mmi ${SAMPLE}_filtered_ONT.fastq.gz > ${SAMPLE}_minimap2.paf
```

- `-x map-ont`: specifies that you are using nanopore reads.
- `${SAMPLE}.mmi`: the index file created in step 1.
- `${SAMPLE}_filtered_ONT.fastq.gz`: is your nanopore sequencing data.
- `${SAMPLE}_minimap2.paf`: the PAF alignment/map file where the mapped reads will be saved. PAF is the default output format of `minimap2`

##### 3) Let's run racon

Now, let's proceed with polishing your initial assembly using `racon`. 
You can use the following command as a starting point/guide:

```bash
racon [options] <input_reads.fastq> <input_assembly.fasta> <output_polished.fasta>
```

Replace `[options]` with specific parameters and replace the file names within `<>` with the actual file names. 
Here's an example command:

```bash
racon --match 8 --mismatch -6 --gap -8 --window-length 500 --threads 2 ${SAMPLE}_filtered_ONT.fastq.gz ${SAMPLE}_minimap2.paf ${SAMPLE}_flye.fasta > ${SAMPLE}_flye_racon.fasta
```

Explanation of the command options:

- `--match`: set the minimum coverage required for a consensus base.
- `--mismatch`: score for mismatching bases.
- `--gap`: gap penalty (must be negative).
- `--window-length`: size of window on which partial order alignment (POA) is performed.
- `--threads`: specify the number of CPU threads to use for polishing.
- `${SAMPLE}_filtered_ONT.fastq.gz`: Input nanopore sequencing data.
- `${SAMPLE}_minimap2.paf`: the PAF alignment/map file where the mapped reads will be saved.
- `${SAMPLE}_flye.fasta`: Input initial assembly.
- `${SAMPLE}_flye_racon.fasta`: Output polished assembly file.

Once `racon` completes polishing the assembly, you will find the output `${SAMPLE}_flye_racon.fasta` in the directory where you ran the command. You can use tools like `QUAST` to assess the quality and completeness of your assembly. Remember, we used `QUAST` in [week 06](https://github.com/ESR-NZ/Training/tree/main/Advanced_Genomics_Workshop/Week_06) 

#### Question

**After generating the polished assembly file (e.g., `${SAMPLE}_flye_racon.fasta`), and Log files, please compare the total genome length to the unpolished assembly**

### Polishing an assembly generated from nanopore reads using medaka

`medaka` is a powerful tool developed by ONT (Oxford Nanopore Technologies) for polishing nanopore-based assemblies.

#### Data preparation

Ensure you have the following files ready:

- Nanopore sequencing data in `FASTQ` format (i.e., 22AR0430_filtered_ONT.fastq.gz)
- The polished assembly of the genome in `FASTA` format (i.e., 22AR0430_flye_racon.fasta)

Please make sure these files are located in the same directory where you plan to run `medaka`.

#### Polishing with medaka

Now, let's proceed with polishing your initial assembly using `medaka`. The basic command structure is as follows:

```bash
medaka_consensus -i <nanopore_reads.fastq.gz> -d <racon_polished_assembly.fasta> -o <output_directory>
```

Replace `<nanopore_reads.fastq.gz>`, `<racon_polished_assembly.fasta>`, and `<output_directory>` with specific file paths and directory names. 
Here's an example command:

```bash
medaka_consensus -d ${SAMPLE}_flye_racon.fasta -i ${SAMPLE}_filtered_ONT.fastq.gz -o ${SAMPLE}_medaka -t 2 -m r941_min_hac_g507
```

`medaka` will generate polished assemblies and other output files in the specified output directory.

Once `medaka` completes polishing the assembly, you will find several output files in the specified `<output_directory>`. The primary assembly output will be in the `assembly.fasta` file, which contains the assembled genome. You can use tools like `QUAST` to assess the quality and completeness of your assembly. 

#### Question

**After generating the medaka polished assembly file (e.g., `${SAMPLE}_medaka.fasta`), and Log files, please compare the total genome length to the unpolished and racon polished assembly**

## Why have I learnt this?

You have learned to use `flye` as its is a popular and widely used _de novo_ genome assembly tools that handle long-read sequence data.

`quast` is a commonly used tool for assessing the quality of genome assemblies. `quast` allows you to compare the accuracy and completeness of different assemblies. 

`racon` and `medaka` are tools used for polishing out potential errors within nanopore-based assemblies.

These tools help ensure that the genome assembly is high quality and can be used for downstream analyses.

## Whakamihi! You did it!

That's it for this tutorial on _de novo_ genome assembly using long-read sequence data! You have assembled your long-read sequence data into a draft genome using `flye`, and have successfully used `quast` to assess the quality metrics of your genome assemblies. You have also used read mapping approaches to generate a concensous to polish out any errors that may have come about during the initial assembly process. If you have any further questions, feel free to ask.

